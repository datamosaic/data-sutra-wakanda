var TIME = require("Utility/time.js");var workerTimestampOpened = new Date();console.log( "worker opened at " + TIME.dateTimeUTCToString(workerTimestampOpened) );//==============================================================================// default "constants"var DEFAULT_WORKER_POLLING = {	PERIOD: { STD: 60, MIN: 0.5, MAX: 3600 },  // seconds	TIMEOUT: { STD: 180, MIN: 4, MAX: 7200 },  // seconds	ALERT: { STD: 60, MIN: 0.25, MAX: (24*60) },  // minutes	STATCYCLE: { STD: 10, MIN: 0, MAX: (24*60*60) }  // ordinal up to 1 stat save per day};//==============================================================================// worker vars and init// initialized once when worker is started the first timevar workerPollingPeriod = DEFAULT_WORKER_POLLING.PERIOD.STD;  // secondsvar workerPollingTimeout = DEFAULT_WORKER_POLLING.TIMEOUT.STD;  // seconds//var workerAlertPeriod = DEFAULT_WORKER_POLLING.ALERT.STD;  // minvar workerPollingStatCycle = DEFAULT_WORKER_POLLING.STATCYCLE.STD;  // ordinalvar workerPollingStatCyclePosition = 0;var workerInterval = null;var workerIsRunning = false;var workerTimestampStarted = null;//==============================================================================// helpersfunction canStartServer( selserver ){	function dsFieldStringValid( fieldToTest )	{		return fieldToTest !== null && fieldToTest.length > 0;	}	return dsFieldStringValid( selserver.admin_ip )	  && dsFieldStringValid( selserver.admin_username )	  && dsFieldStringValid( selserver.admin_script_path )	  && dsFieldStringValid( selserver.admin_script_start );}function workerPollingHelper(){	//----------------------------------------------	// need permisison to access ds.	// needs to be called here. doesn't work in workerStart()/Stop().	// revoke permission when finished.	var workerPromoteToken = currentSession().promoteWith('Admin');		//----------------------------------------------	// stats save cycle position	++workerPollingStatCyclePosition;	var flagSaveStats = workerPollingStatCyclePosition == workerPollingStatCycle;	//console.log( "stat cycle: " + workerPollingStatCycle + "   pos: " + workerPollingStatCyclePosition + "   ergo: " + flagSaveStats );		//----------------------------------------------	// loop over servers currently active	var servers = ds.Server.query( "includeInPoll == true" );	for( var i = 0; i < servers.length; ++i )	{		//----------------------------------------------		// poll server		var myserver = servers[i];		var retval = KB.callAPI( "SRVRMON.getAndStoreStats.general", [ myserver.ID, flagSaveStats ] );		myserver.refresh();  // need to get current version of record since API call changed it (or else save() doesn't work)		//----------------------------------------------		// poll succeeded		if( retval === true )		{			// last reached was set to now in api getAndStoreStats()						// went down before, now up			if( myserver.went_down !== null )			{				// tried to restart				if( myserver.admin_start_initiated !== null )				{					// server came up before giving up ==> successful restart					if( myserver.admin_start_gaveup === null )					{						var emailResult = KB.callAPI( "SRVRMON.sendEmail.serverAlert", [ myserver.ID, 'uprestartsuccessful' ] );						console.log("Sent server ==> uprestartsuccessful <== email: " + emailResult.count + " of " + emailResult.expected + " expected.");					}					// server came up but gave up: restart wasn't successful or took longer than expected					else					{						var emailResult = KB.callAPI( "SRVRMON.sendEmail.serverAlert", [ myserver.ID, 'uprestartfailed' ] );						console.log("Sent server ==> uprestartfailed <== email: " + emailResult.count + " of " + emailResult.expected + " expected.");					}					myserver.admin_start_initiated = null;					myserver.admin_start_gaveup = null;					myserver.save();				}				else				{					// send alert server up (no restart attempted)					var emailResult = KB.callAPI( "SRVRMON.sendEmail.serverAlert", [ myserver.ID, 'up' ] );					console.log("Sent server ==> up <== email: " + emailResult.count + " of " + emailResult.expected + " expected.");				}				myserver.went_down = null;				myserver.save();			}		}				//----------------------------------------------		// poll failed		else if( retval === false )		{			// first time going down, now unreachable			if( myserver.went_down === null )			{				var timeStart = ( myserver.last_reached !== null ? myserver.last_reached : workerTimestampStarted );				var timeNow = new Date();				var durStartToNow = ( timeNow - timeStart ) / 1000;  // ms to s								// met/exceeded alert period ==> server is down				if( durStartToNow >= workerPollingTimeout )				{					myserver.went_down = timeStart;					myserver.save();										if( canStartServer(myserver) )					{						// send server start request						var remoteResult = KB.callAPI( "SRVRMON.doRemote.serverStart", [ myserver.ID ] );						// *** need to change result from string to bool(?) and do something with it if remote request failed						myserver.admin_start_initiated = new Date();						myserver.save();					}					else					{						// send alert server down (no restart)						var emailResult = KB.callAPI( "SRVRMON.sendEmail.serverAlert", [ myserver.ID, 'down' ] );						console.log("Sent server ==> down <== email: " + emailResult.count + " of " + emailResult.expected + " expected.");					}				}			}						// went down before, now unreachable, still down			else			{				// now unreachable, went down, tried restart				if( myserver.admin_start_initiated !== null )				{					var timeNow = new Date();					var durStartInitToNow = ( timeNow - myserver.admin_start_initiated ) / 1000;  // ms to s					// tried restart longer than alert timeout and haven't given up yet					if( durStartInitToNow >= workerPollingTimeout && myserver.admin_start_gaveup === null )					{						myserver.admin_start_gaveup = new Date();						myserver.save();						var emailResult = KB.callAPI( "SRVRMON.sendEmail.serverAlert", [ myserver.ID, 'downrestartfailed' ] );						console.log("Sent server ==> downrestartfailed <== email: " + emailResult.count + " of " + emailResult.expected + " expected.");					}				}				}								}  // poll failed			}  // for servers		if( workerPollingStatCyclePosition >= workerPollingStatCycle )	{		workerPollingStatCyclePosition = 0;	}		currentSession().unPromote(workerPromoteToken);}  // function//==============================================================================// actionsfunction workerStart(){	if( workerIsRunning === true )		return;	if( workerInterval === null )	{		workerPollingStatCyclePosition = 0;		// setInterval waits for the interval to elapse before the first time so do one manually		workerPollingHelper();		workerInterval = setInterval( workerPollingHelper, workerPollingPeriod * 1000 );  // time in ms	}	workerIsRunning = true;	workerTimestampStarted = new Date();	console.log("worker polling started at " + TIME.dateTimeUTCToString(workerTimestampStarted) );}function workerStop(){	if( workerIsRunning === false )		return;	if( workerInterval !== null )	{		clearInterval( workerInterval );		workerInterval = null;		workerPollingStatCyclePosition = 0;	}	workerIsRunning = false;	var timestampFinished = new Date();	console.log("worker polling stopped at " + TIME.dateTimeUTCToString(timestampFinished)	  + " and ran for " + TIME.timeElapsedToString( workerTimestampStarted, timestampFinished ) );	workerTimestampStarted = null;}function workerClose(){	workerStop();	console.log("worker closed at " + TIME.dateTimeUTCToString(new Date()));	close();}//==============================================================================// set / getfunction workerGetPrefs(){	var getprefsObj = {		running: workerIsRunning,		period: workerPollingPeriod,		timeout: workerPollingTimeout,		//alertperiod: workerAlertPeriod,		statcycle: workerPollingStatCycle	};	return getprefsObj;}function workerSetPrefs( prefsToSet ){	// if worker is running, stop temporarily and restart after setting prefs	var startWorkerAgain = false;	if( workerIsRunning === true )	{		startWorkerAgain = true;		workerStop();	}		var prefsToReturn = {};	if( prefsToSet.hasOwnProperty('period') )	{		if( ! ( prefsToSet.period >= DEFAULT_WORKER_POLLING.PERIOD.MIN && prefsToSet.period <= DEFAULT_WORKER_POLLING.PERIOD.MAX ) )			prefsToSet.period = DEFAULT_WORKER_POLLING.PERIOD.STD;		workerPollingPeriod = prefsToSet.period;				prefsToReturn.period = workerPollingPeriod;	}	if( prefsToSet.hasOwnProperty('timeout') )	{		if( ! ( prefsToSet.timeout >= DEFAULT_WORKER_POLLING.TIMEOUT.MIN && prefsToSet.timeout <= DEFAULT_WORKER_POLLING.TIMEOUT.MAX ) )			prefsToSet.timeout = DEFAULT_WORKER_POLLING.TIMEOUT.STD;		workerPollingTimeout = prefsToSet.timeout;		prefsToReturn.timeout = workerPollingTimeout;	}//	if( prefsToSet.hasOwnProperty('alertperiod') )//	{//		if( ! ( prefsToSet.alertperiod >= DEFAULT_WORKER_POLLING.ALERT.MIN ) && ( prefsToSet.alertperiod <= DEFAULT_WORKER_POLLING.ALERT.MAX ) )//			prefsToSet.alertperiod = DEFAULT_WORKER_POLLING.ALERT.STD;//		prefsToReturn.alertperiod = workerPollingAlert;//	}	if( prefsToSet.hasOwnProperty('statcycle') )	{		if( ! ( prefsToSet.statcycle >= DEFAULT_WORKER_POLLING.STATCYCLE.MIN && prefsToSet.statcycle <= DEFAULT_WORKER_POLLING.STATCYCLE.MAX ) )			prefsToSet.statcycle = DEFAULT_WORKER_POLLING.STATCYCLE.STD;		workerPollingStatCycle = prefsToSet.statcycle;		prefsToReturn.statcycle = workerPollingStatCycle;	}	if( startWorkerAgain === true )	{		workerStart();	}	return prefsToReturn;}function workerGetStatus(){	var statusobj = {		running: workerIsRunning,		opened: workerTimestampOpened,		started: workerTimestampStarted	};	return statusobj;}//==============================================================================// message receiving from server-side module// onconnect is whenever someone connects to this SharedWorker to talk to itonconnect = function(msg){	var port = msg.ports[0];  // bidirectional	port.onmessage = function(event)	{		var message = event.data;		switch(message.command)		{			//--------------------------------			// actions			case 'start':				workerStart();				break;			case 'stop':				workerStop();				break;			case 'close':				workerClose();				break;			//--------------------------------			// set			case 'setprefs':				var setprefsObj = workerSetPrefs(message.payload);				port.postMessage( { response: "prefs", payload: setprefsObj } );				break;			//--------------------------------			// get			case 'getstatus':				port.postMessage( { response: "status", payload: workerGetStatus() } );				break;			case 'getprefs':				port.postMessage( { response: "prefs", payload: workerGetPrefs() } );				break;			//--------------------------------			// unknown			default:				console.log( "workerPolling: unrecognized command " + message.command );				break;		}	}}