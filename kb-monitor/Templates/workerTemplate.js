// from Web Worker TR// http://www.w3.org/TR/workers/// Generally, workers are expected to be long-lived, have a high start-up// performance cost, and a high per-instance memory cost.// messages from outside to worker// { command: "stringcommand", payload: relevantData }// messages from worker to outside// { response: "stringresponse", payload: relevantData }//==============================================================================// anything outside of function definitions is executed once in initializationvar workerOptions = {	period = 30  // time in seconds};var workerFlags = {  // true means do that subtask	whiskey = true,	tango = true,	foxtrot = false};var workerState = {	intervalID = null,	isRunning = false,};//==============================================================================function workerHelper(){	// do the stuff that will occur on a regular basis	if( workerFlags.whiskey === true )	{	}	if( workerFlags.tango === true )	{	}	if( workerFlags.foxtrot === true )	{	}}//==============================================================================// standard functionsfunction workerStart(){	if( workerState.isRunning === true )		return;	if( workerState.intervalID === null )	{		workerHelper();  // setInterval waits for whole interval first so do one immediately		workerState.intervalID = setInterval( workerHelper, workerOptions.period * 1000 );  // time in ms	}		workerState.isRunning = true;}function workerStop(){	if( workerState.isRunning === false )		return;	if( workerState.intervalID !== null )	{		clearInterval( workerState.intervalID );		workerState.intervalID = null;	}	workerState.isRunning = false;}function workerSetPeriod( newPeriod ){	workerOptions.period = newPeriod;		// if nothing is actually running, we're finished so get out of here	if( workerState.isRunning === false )		return;		// if is running then restart with newly set period	if( workerState.isRunning === true )	{		clearInterval( workerState.intervalID );		workerHelper();  // do one immediately		workerState.intervalID = setInterval( workerHelper, workerOptions.period * 1000 );	}}//==============================================================================function workerSetSomething( somethingToSet ){	workerOptions.something = somethingToSet;		// if nothing is actually running, we're finished so get out of here	if( workerIsRunning === false )		return;}//==============================================================================// onconnect is whenever someone connects to this SharedWorker to talk to itonconnect = function(msg){	var port = msg.ports[0];  // port is bidirectional	port.onmessage = function(event)	{		var message = event.data;		switch(message.command)		{			//======================================			// standard cases			case 'start':				workerStart();				break;			case 'stop':				workerStop();				break;			case 'isrunning':				port.postMessage( { response: "running", payload: workerIsRunning } );  // send message to inquisitor				break;			case 'setperiod':				workerSetPeriod(message.payload);				break;			case 'getperiod':				port.postMessage( { response: "period", payload: pollingPeriod } );				break;			//======================================			// custom cases			case 'setsomething':				workerSetSomething(message.payload);				break;			case 'getsomething':				port.postMessage( { response: "something", payload: workerOptions.something } );  // send something to inquisitor				break;			//======================================			default:				console.log( "workerTemplate: unknown command! " + message.command );				break;		}	}}