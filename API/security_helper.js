/* * This file is meant to be required and called from the bottom  * of every API.  It removes access to calls for which the current * session doesn't have access * * @example <caption>Paste this code at the bottom of your main API javascript sheet, replacing out arguments appropriately</caption> * require( (FileSystemSync("PROJECT").path.split('/').slice(0,FileSystemSync("PROJECT").path.split('/').length-2).join('/')) + '/AccessControl' + '/API/security_check.js' )("API",API); */exports.init = initAll;exports.controller = controller;exports.external = external;/** * Secure access & control for particular revision of API actions * @param {String} module IDentifier for requested module * @param {Object} actions All actions provided by requested API * @return {Object} API revision with access control */function init(module,actions) {	// what is the url for the xhr request	var URL = require( (FileSystemSync("PROJECT").path.split('/').slice(0,FileSystemSync("PROJECT").path.split('/').length-2).join('/')) + '/AccessControl' + '/API/security_registry.js' ).path('AC');		// get permitted actions (via xhr except for this one place)		// allowed actions the same for all versions; future can be different by version	var xhr = require(FileSystemSync("EXTENSIONS_USER").path + "Modules/XHR");	var actionsAllowed = xhr.post(URL, "security", module).result;		/**	 * Recursively touch all properties on API	 * @param {Object} parent Object to iterate over	 * @param {String} path Breadcrumb to where this function is	 */	function iterate(parent,path) {				// non-null, really an object		if (parent && typeof parent == 'object' && typeof parent.hasOwnProperty == 'function') {			// keep track of where we are in the stack			if (path) {				path += '.';			}			else {				path = '';			}						for (var i in parent) {				iterate(parent[i], path + i);			}		}		// at a leaf, check if function not in action list, replace with dummy function that returns error object		// allow API.name (name of this api) and API.external (call to external APIs) to remain		//TODO: possibly change to only replace out functions and leave properties alone		else if (actionsAllowed.indexOf(path) == -1 && eval('typeof actions.' + path) == 'function') {			eval('actions.' + path + ' = accessDenied');		}	}//	debugger	// iterate over all possible actions in module object	iterate(actions);		// return actions currently logged in user can perform	return actions;};/** * Bring in all available revisions of API and check security * @param {String} module IDentifier for requested module * @param {Object} API All actions provided by requested API */function initAll(module,API) {	var apiDirectory = FileSystemSync("PROJECT").path + 'API/';	var i = 1;	while (File(apiDirectory + module + '_v' + i + '.js').exists) {		// get particular version of api methods		API.version.push(require(apiDirectory + module + '_v' + i + '.js'));				// add security restrictions to api methods		init(module,API.version[i - 1]);				// increment to next possible api revision		i++;	}		// take active api and tack on to top level	if (API.activeVersion && API.version[API.activeVersion - 1] != null) {		var __hasProp = {}.hasOwnProperty;		var __extends = function(child, parent) { 			for (var key in parent) { 				if (__hasProp.call(parent, key)) 					child[key] = parent[key]; 			}			function ctor() { 				this.constructor = child; 			} 			ctor.prototype = parent.prototype; 			child.prototype = new ctor(); 			child.__super__ = parent.prototype; 			return child; 		}		__extends(API,API.version[API.activeVersion - 1]);		var z = '';	}}/** * Generic error function */function accessDenied() {	return { 		'error': 401, 		'errorMessage': 'Unauthorized'	};}/** * Called externally (xhr): request handler comes in here * @param {Object} API The requested API * @param {HTTPRequest} request * @param {HTTPResponse} response * @return {JSON} */function controller (API, request, response) {	var 		call,		token,		version,		params,		fx;	// TODO: sometimes this debugger is needed for cross-project api calls//	debugger		//TODO: better logic to pull this out from url	call = request.url.split('/')	token = call[2]	version = call[3]		// based on request params, call a method	params = (request && request.hasOwnProperty('body') && request.body.length) ? JSON.parse(request.body) : new Object();	try {		// should version requested in params or url have precedence?		version = params.version ? params.version : (version ? version : API.activeVersion);		fx = eval('API.version[' + (version - 1) + '].' + params.method);	}	catch (e) {			}		// check gatekeeper security by...		// localhost	if (request.host.indexOf('localhost') == 0 || 		// whitelisted host		API.accessHost.indexOf(request.remoteAddress) != -1 ||		// debug token present		API.accessToken.indexOf(token) != -1) {				// this method exists, run it		if (typeof fx == 'function') {			response.contentType = 'application/json';			return JSON.stringify(fx.apply(this,params.arguments));		}	}};/** * Brokers the call to external APIs * @param {Object} API The requested API * @param {String} method The way you would normally call a method if it were required in....example: "AC.organization.getAll" * @param {Array} [arguments] Array of arguments to be passed to this method * @param {Number} [version] Which version of API to call * @return Whatever the call returns */function external(API, method, arguments, version) {	//TODO: beef up initial error check...probably need to have specific class for all APIs	if (method) {		var apiName = method.split('.')[0];		method = method.substr(apiName.length + 1);				// get server/port for external project		if (API.name != apiName) {			var URL = require( (FileSystemSync("PROJECT").path.split('/').slice(0,FileSystemSync("PROJECT").path.split('/').length-2).join('/')) + '/AccessControl' + '/API/security_registry.js' ).path(apiName);		}		// send request without domain to keep server from crashing		else {			var URL = '/'		}				// get permitted actions (via xhr except for this one place)		var xhr = require(FileSystemSync("EXTENSIONS_USER").path + "Modules/XHR");		var results = xhr.post(				URL, 				"api", 				{					method: method,					//TODO: debug issues when passing in arguments					arguments: arguments,					version: version				}			).result;				return results;	}}