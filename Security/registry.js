/* * This file provides registered actions per credentials and provides how to  * access the projects (what URL they are being served from) */ /** * Aggregate actions, allURLs, paths (on disk), and allRoutes for all included projects */var allActions = new Object();var allURLs = {	server : new Object(),	developer : new Object()}var allPaths = new Object();var allRoutes = new Object();	// get solution's projectsvar configPath = FileSystemSync("SOLUTION").path;var solutionDir = Folder(configPath);for (var j in solutionDir.files) {	if (solutionDir.files[j].extension === "waSolution") {		var solutionFile = File(solutionDir.files[j].path);		break	}}	configPath = configPath.split('/');configPath.pop();configPath.pop();configPath = configPath.join('/') + '/';	var projects = JSON.parse(XmlToJSON(solutionFile.toString(), "json-bag", "solution"));	// get all projects to be operated onfor (var i in projects) {	// only work on project node (weird issue with __CDATA)	if (i.toLowerCase() == 'project') {		// loop over all projects		for (var j = 0; j < projects[i].length; j++) {			// check that this project has a non-null name			if (projects[i][j].hasOwnProperty('path') && projects[i][j].path) {				var regex =  new RegExp(/\((.*)\)/);				var project = projects[i][j].path.split('/');				var id = regex.exec(project[2]) ? regex.exec(project[2])[1].toLowerCase() : '';				var apiSecure = configPath + project[1] + '/Security/' + id + '.json';				var security = File(apiSecure);									if (security.exists) {					var api = JSON.parse(security.toString());											// go grab actions (TODO: move this to the version level)					var v1API = File(configPath + project[1] + '/API/' + id + '_1.js')											// make sure there is a place to store actions					if (!(api.actions instanceof Array)) {						api.actions = new Array();					}											if (v1API.exists) {						v1API = v1API.toString();													var derivedActions						var derivedRegex = /@public[\s\S]*?\*\/\s+(.*?)(?:\s+)?=/gi;													while (derivedActions = derivedRegex.exec(v1API)) {							var methodName = derivedActions[1].split('.').slice(1).join('.');															if (api.actions.indexOf(methodName) == -1) {								api.actions.push(methodName);							}						}					}											// assign out					allActions[api.name] = api.actions;					allURLs.server[api.name] = api.path.server;					allURLs.developer[api.name] = api.path.developer;					allPaths[api.name.toLowerCase()] = configPath + project[1];					allRoutes[api.name.toLowerCase()] = api.routes || new Array();				}			}		}	}}// called in security_check via requirevar module = module || new Object();if (module && module.exports) {	/**	 * Actions allowed per API; called via xhr	 *	 * @param {HTTPRequest} request	 * @param {HTTPResponse} response	 * @return {JSON}	 */	module.exports.actions = function actions(request, response) {		var id = (request && request.hasOwnProperty('body') && request.body.length) ? JSON.parse(request.body) : '';			response.contentType = 'application/json';			// this module exists, grab its possible api actions		if (id && allActions.hasOwnProperty(id)) {			return JSON.stringify(allActions[id]);		}		// return nothing		else {			return JSON.stringify(new Array());		}	}		/**	 * How to reference each project	 * 	 * @param {String}  module IDentifier for requested module	 * @return {String} Host (including port, if any)	 */	module.exports.path = function project(module) {		// some check to see if in developer		if (true) {			return allURLs.developer[module];		}		else {			return allURLs.server[module];		}	}		module.exports.projectPath = function projectPath(id) {		return allPaths[id.toLowerCase()];	}		module.exports.routes = function routes(id) {		// if no allRoutes specified for first identifier, probably is single-project solution; return allRoutes for "app"		if (id && allRoutes.hasOwnProperty(id.toLowerCase())) {			return allRoutes[id.toLowerCase()];		}		return allRoutes.app;	}}