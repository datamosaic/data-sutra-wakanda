var session;exports.session = function() {	return session || {};}/** * Is the current session logged in and valid? */exports.valid = function() {	return (session && session.storage) ? (session.storage.validLogin || false) : false;}/** * Attempt to login using default login form * */function LoginListener(userName, passwordOrKey, secondIsAKey) {	//TODO: switch to using sha256 custom or higher		session = currentSession();		// login valid	var auth = authenticate(userName,passwordOrKey);	if (auth.error != 401) {		// determine group belonging to and set up permissions		if (true) {			var group = 'Admin';						// api				// rebuild api with current credentials							// TODO: navigation						// TODO: SaaS filtering, etc		}				// set status as logged in			//TODO: set this to be some UUID so more hack proof		session.storage.validLogin = true;	}		return auth;};exports.login = LoginListener;/** * Log out current user and return to login form * */function logout() {	// mirror what happens in login, but do the reverse		// set status as logged out		//TODO: set this to be some UUID so more hack proof	if (session && session.storage && session.storage.validLogin) {		return delete session.storage.validLogin;	}		showLogin();		return false;}exports.logout = logout;/** * Show login form * */function showLogin() {	}exports.loginForm = showLogin;/** * Authenticate credentials * @param {String} user * @param {String} pass * @param {String} [type='default'] Type of authentication to be performed; defaults to kabootit internal */function authenticate(user,pass,type) {	//default will be to reject login	var valid = {		// the error number (passed as a number)		error: 401,		//the text of the error		errorMessage: "Unauthorized"	};		// kabootit internal auth	if (!type || type == 'default') {		var theUser = directory.internalStore.User({name: user});		// user exists in the directory		if (theUser != null) {			// allow directory authentication			return false;		}		// use data from the project for login		else {			// flip around to cross project communication			var securityDS = solution.getApplicationByName("ה Access & control (AC)").ds;			var record = securityDS.User({name:user});			// if a user was found			if (record != null) {				// see if the stored hash value is correct				if (record.password === directory.computeHA1(user, pass)) {					var groups = [];					var putIntoStorage = {myID: record.ID};					// switch (theEmployee.accessLevel){					// 	case 1: 					// 		theGroups = ['Admin'];					// 		break;					// 	case 2: 					// 		theGroups = ['Manager'];					// 		break;					// 	case 3: 					// 		theGroups = ['Worker'];					// 		break;					// }					valid = {						ID: record.ID, 						name: record.name, 						fullName: record.firstName + ' ' + record.lastName, 						belongsTo: ['Admin'], //theGroups,						storage: putIntoStorage					};				}			}		}				// var valid = {		// 	// a UUID string referencing the user. It can be any UUID but must not be an existing user ID		// 	ID: generateUUID(),		// 	// a string which will be the user name attribute		// 	name: user || 'Troy',		// 	// a string which will be the user full name attribute		// 	fullName: '"' + (user || 'Troy') + '" ' + "Troy Bob Larry",		// 	// an array of UUID strings, or		// 	// an array of group names referencing the groups the user must belong to		// 	belongsTo: [generateUUID()],		// 	// a Storage object which is the sessionStorage property of the user session		// 	storage: (session && session.storage) ? session.storage : {}		// };	}		return valid;}exports.authenticate = authenticate;